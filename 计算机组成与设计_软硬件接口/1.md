# 计算机组成原理与设计 软硬件接口

- 笔记参考的是David A. Patterson 和 John L. Hennessy的计算机组成与设计第五版，实现的指令集是MIPS。只讨论部分理论部分。

# 5. 存储器层次结构
## 5.1 引言
1. 局部性原理->(空间局部性和时间局部性原理)
2. 我们将一个两级层次结构存储单元中信息交换的最小单位称为行或者块
![](img/截屏2024-03-14%2016.08.04.png)
---
## 5.2 存储器技术
参考 https://blog.csdn.net/bay_Tong/article/details/108737980
1. SRAM  
   - 利用双稳态触发器，存储元是用双稳态触发器（六管 MOS）来记忆信息的，即使信息被读出，它仍保持其原状态而不需要再生（非破坏性读出）；只要电源被切断， 原来的保存信息便会丢失，它是易失性半导体存储器。  
   - 一般用来组成高速缓冲存储器Cache。
2. DRAM
   - 是一种半导体存储器，主要是利用电容内存储电荷的多少来代表一个二进制比特是1还是0。由于在现实中晶体管会有漏电电流的现象，导致数据毁损，因此DRAM需要周期性地进行充电刷新
   - 不同的刷新方式
   - ![](img/截屏2024-03-14%2016.18.27.png)
   - ![](img/截屏2024-03-14%2016.18.37.png)
   - ![](img/截屏2024-03-14%2016.18.45.png)
   - ![](img/截屏2024-03-14%2016.18.57.png)

3. 主存储器与CPU的连接
![](img/截屏2024-03-14%2016.21.38.png)
- MAR：存储器地址寄存器，接收由程序计数器的指令地址或来自运算器的操作数的地址，以确定要访问的单元
- MDR：存储器数据寄存器，是向主存写入数据或从主存读出数据的缓冲部件
- 注意 MIPS并没有明确的MAR（存储器地址寄存器）和MDR（存储器数据缓冲寄存器）内存访问通常是通过专门的加载（load）和存储（store）指令来完成的

## 5.3 cache的基本原理
1. 直接映射
![](img/截屏2024-03-14%2016.26.34.png)  
   - cache块地址 = 内存块地址 mod cache块数 (这样我们内存块地址的低位，offset位除外，就相当于cache块地址，高位相当tag位)
   - 我们在cache中增加一组标记位用来判断cache中的**字**是否是我们需要的
   - 我们在cache中增加一个标记位用来判断cache中的数据是否有效
   - 现代cache的命中率可达95%
---
2. cache的访问
   ![](img/截屏2024-03-14%2016.38.54.png)

- ![](img/截屏2024-03-14%2016.42.57.png)
- 如上题 除去MIPS按字编码、按字节寻址出现的2位offset之外，我们的一个块内有四个字，还需额外的两位offset。
---
## 5.4 cache的缺失
参考 https://blog.csdn.net/m0_55746113/article/details/128881962?spm=1001.2014.3001.5506
1. 较大的cache块能够很好的利用空间局部性以降低确实率。但当cache块达到一定大小时，这种收益也随之下降。一是，块之间竞争的加大，二是块内空间局部性的减弱。另外，随着块的变大，cache块缺失的成本增加。
![](img/截屏2024-03-14%2016.54.16.png)

2. cache缺失时的处理
![](img/截屏2024-03-14%2016.56.53.png)

3. 写操作处理
![](img/截屏2024-03-14%2016.59.54.png)
- 对于cache的写操作，分为要写的主存单元在cache中也就是写命中，以及写缺失。    
- 我们首先讨论写命中
    
  **写直达**  
  -  也叫做全写、写通、写穿，指的是写操作总是同时更新cache和主存。以保持二者的一致性。这种方式的访问主存次数增加，速度变慢，但是一致性好。
  -  写直达一般要配合写缓冲一起使用。写缓冲也是用 SRAM 来制造的，意味着对写缓冲的读和写操作会比较快。
  -  当要把数据写入主存时，将他放入write buffer,cpu不被阻塞，缓冲由其他的控制电路处理。如果缓冲满了，cpu必须停下，等待缓冲区释放。
  -  ![](img/截屏2024-03-14%2017.08.53.png)

  **写回**
  - 指的是，当cpu对cache进行写操作时，只修改cache，不修改主存。直到此块被换出时，才写回主存。相对于写直达，写回的实现更复杂。
- 接下来讨论写缺失  
  **写分配**
  - 当cpu对cache缺失时，把主存的块调入cache，在cache中搭配写回法进行处理  
   
  **写不分配**
  - 当cpu对cache缺失时，直接在cache中修改而不调入主存。
---
## 5.5 cache性能评估与改进

1. 我们首先探讨cache性能评估的指标
```
cpu时间 = (cpu执行时钟周期 + cpu阻塞时钟周期) * 时钟周期
```

2. 我们讨论通过更灵活的方式放置cache块来减少cache缺失  
  
**全相连映射**  
- 主存中的一个地址可被映射进任意cache line。当寻找一个地址是否已经被cache时，需要遍历每一个cache line来寻找，这个代价很高。Cache的利用率高，块冲突概率低

**组相连映射**  
- 组相联映射实际上是直接映射和全相联映射的折中方案，主存和Cache都分组，主存中一个组内的块数与Cache中的分组数相同，组间采用直接映射，组内采用全相联映射。

![](img/截屏2024-03-14%2019.17.33.png)

3. 在cache中查找、替换一个块
![](img/截屏2024-03-14%2019.25.15.png)

- LRU(Least Recently Used) 最近最少使用算法。在替换cache块时，我们总是替换最长时间未被使用的那块。

## 5.6 可信存储器层次
1. 可靠性是一个系统能持续为用户提供服务的度量。平均无故障时间(MTTF)是一个可靠性度量方法。与之对应的是年失效率(AFR),是指在给定MTTF的情况下，一年器件失效比例。
![](img/截屏2024-03-14%2019.38.31.png)

2. 纠错码  
**奇偶校验码**
   - 奇校验。我们的冗余位使得整个编码的1的个数和为奇数。
   - 偶校验。我们的冗余位使得整个编码的1的个数和为偶数。
   - 缺点，奇偶校验码无法知道是哪一位出错，也只能检测偶数位变化。
  ---
**汉明码**
参考 https://blog.csdn.net/a493823882/article/details/109343791
![](img/截屏2024-03-14%2019.48.21.png)

## 5.7 虚拟存储器

1. 之前我们已经讨论了cpu、cache、主存之间的关系。同样的，我们将由磁盘实现的辅助存储器作为主存的cache的技术称为虚拟存储技术。从历史观点来看，虚拟存储技术主要有两个动机：
   - 允许多个程序共享内存空间
   - 消除一个小而受限的主存空间对于程序的影响
![](img/截屏2024-03-17%2022.08.42.png)

2. 虚拟存储器中，虚地址被划分为虚页号和页偏移。物理页号构成物理地址的高位，页偏移构成物理地址的低位。页偏移域决定了页的大小。物理页号和虚页号不同，拥有比物理地址大得多的寻址空间是虚地址完成的功能之一。而从虚拟页号到物理页号的变换则是关键。
![](img/截屏2024-03-17%2022.10.31.png)
3. 缺页的高代价
![](img/截屏2024-03-17%2022.15.20.png)
4. 页的存放和查找
   - 由于页的缺失的代价巨大，我们不能像cache一样有多种存放方式。我们在此为了降低页的位置冲突，使用全相连放置。而页的替换则可以使用灵活的算法、复杂有效的数据结构以期尽可能降低缺页发生的可能。
   - 由于使用的是全相连映射、我们的困难也随之而来 -- 页的定位或者说页的转换。我们在虚拟存储技术中，使用了页表解决这个问题。页表，使用虚拟地址中的页号作为索引，来找到相对应的物理地址。页表被放置在主存中。为了指出页表的位置，我们还需要一个页表寄存器，保存页表的首地址。
   ![](img/截屏2024-03-17%2022.25.05.png)
   ![](img/截屏2024-03-17%2022.26.07.png)
   ![](img/截屏2024-03-17%2022.28.34.png)
5. 关于写
![](img/截屏2024-03-17%2022.32.00.png)
6. 加快地址转换 TLB
   - 由于页表或者说物理地址在主存中，因此，我们每次访存至少两次，第一次将虚拟地址变为物理地址，第二次才获得数据或者指令。为了提高效率，我们在cache中也放置了一个特殊的cache用于追踪最近访问过的页。被称作快表(TLB)。
   ![](img/截屏2024-03-17%2022.37.43.png)
   ![](img/截屏2024-03-17%2022.38.02.png)
   - 在上面这段话中，有一个非常重要的地方需要注意，就是它阐明了TLB缺失的处理。
   - 需要注意，TLB与cache没有必然联系，在TLB中命中的数据不一定也在cache中
7. 虚存、TLB、cache
![](img/截屏2024-03-17%2022.46.52.png)
![](img/截屏2024-03-17%2022.47.33.png)
   - 需要注意，就像表的第一项。我们在TLB中命中了物理地址，但是，此时对应的数据不在cache中，这时候就会启动cache缺页的流程。 
8. 虚拟存储器中的保护
![](img/截屏2024-03-17%2022.55.01.png)

- 如果我们的操作系统来管理程序页表，并使得虚拟地址映射的不相交的物理地址中，这样就可以做到进程之间的隔离。这样一来，操作系统必须将修改页表的权力回收。
- 但是，当我们的两个程序希望互相访问数据时，此时就必须通过操作系统来修改页表。
![](img/截屏2024-03-17%2023.03.55.png)
- 上图中，为了防止上下文切换时，后来者访问了前者的数据，必须进行TLB的清除。假如，在P1的TLB中，有一个项(1234->00002,1234为虚拟地址，1234为实际的物理地址)，我们要注意，物理地址是主存地址，是唯一的，而虚拟地址则不一定。现在P2还有一个项(1234->00003),此时就P2去TLB中查就会发生访问了P1进程的实际地址，而清空后，由于TLB缺页，则会访问P2的页表。
- 我们可以简单的叙述一下进程上下文切换的过程。首先，我们需要保存当前进程P1恢复所需的状态。如、PC、锁、寄存器、栈、栈指针等。然后，就将加载后来进程P2运行所需的各种数据、状态。此时，我们还需要清空TLB（至少清空关于P1的部分）。另外还要将页表寄存器指向P2的页表。

9. 处理TLB的缺失和缺页
    - 这个部分不做讨论
10. 几个问题
    ![](img/截屏2024-03-17%2023.33.25.png)

    1. 一个块可以被放在何处
    ![](img/截屏2024-03-17%2023.34.40.png)
    2. 如何找到一个块
    ![](img/截屏2024-03-17%2023.36.20.png)
    3. cache缺失时替换哪一块
    ![](img/截屏2024-03-17%2023.37.24.png)
    4. 关于写操作
    ![](img/截屏2024-03-17%2023.39.00.png)
    5. 3C
    ![](img/截屏2024-03-17%2023.40.24.png)
11. 陷阱
    ![](img/截屏2024-03-17%2023.44.38.png)
